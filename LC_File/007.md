#### 鸡蛋掉落

---

题目描述: 你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N`  共有 `N` 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 `F` ，满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。每次*移动*，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 `X` 扔下（满足 `1 <= X <= N`）。你的目标是**确切地**知道 `F` 的值是多少。无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

**思路**

```python
'''
换一个思路来想：“求k个鸡蛋在m步内可以测出多少层”。我们令dp[k][m]表示k个鸡蛋在m步内可以测出的最多的层数，那么当我们在第X层扔鸡蛋的时候，就有两种情况：
1.鸡蛋碎了，我们少了一颗鸡蛋，也用掉了一步，此时测出N-X+dp[k-1][m-1]层，X和它上面的N-X层已经通过这次扔鸡蛋确定大于F；
2.鸡蛋没碎，鸡蛋的数量没有变，但是用掉了一步，剩余X+dp[k][m-1]，X层及其以下已经通过这次扔鸡蛋确定不会大于F；
相加是“本次扔之后可能测出来的层数 + 本次扔之前已经测出来的层数”。
dp[k][m] = dp[k][m-1]+dp[k-1][m-1]+1
'''
class Solution:
    def superEggDrop2(self,K,N):
        dp = [[0 for _ in range(N+1)] for j in range(K+1)]
        for m in range(1,N+1):
            dp[0][m] = 0
            for k in range(1,K+1):
                dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1
                if dp[k][m]>=N:
                    return m
        return N
'''
根据递推公式 如果采用k倒着从大到小计算 就可以只存一行的dp[k] 直接原地更新dp[k] 不影响后续计算 只需要O(K)空间复杂度 O(KlogN) 鸡蛋完全够用的时候 就是走LogN步 最差情况是1个鸡蛋走N步 O(KN)
'''
    def superEggDrop(self,K,N):
        dp = [0] * (K + 1)
        m = 0
        while dp[K] < N:
            m += 1
            for k in range(K, 0, -1):
                # print(m, k)
                dp[k] = dp[k - 1] + dp[k] + 1
        return m

s = Solution()
m = s.superEggDrop(K=2,N=13)
print(m)
```

